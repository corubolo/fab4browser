package org.simplx.c;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.StringUtils;
import static org.testng.Assert.assertEquals;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Optional;
import org.testng.annotations.Parameters;
import org.testng.annotations.Test;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import static org.simplx.c.Stdio.escapeString;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Array;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Formatter;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.regex.Matcher;

/*
 * Parameters that can be set for testng:
 *
 * runDebug         Run the tests that are marked as debug="yes"
 * runFailed        Run the tests that are marked as failed="yes"
 * runIncomplete    Run the tests that are missing an expected attribute
 * runConversions   Run tests that include any conversion in this string
 * runAll           Run all the tests
 *
 * If any of the first four are "true", then only those tests will be run
 * unless runAll is also explicitly set to "true".  If none of these are set,
 * all tests will be run.
 *
 * regenerateExpected
 *                  Regenerate all the "expected" attributes.  Normally, each
 *                  test that is missing an expected attribute will have that
 *                  generated by creating a C file that does the equivalent
 *                  printf, compiling that, and then capturing the output.  If
 *                  regenerateExpected is "true", all tests that are run will
 *                  have their "expected" attributes regenerated.
 *
 * CC               The C compiler to use.  The default is "cc".
 * CC_FLAGS         Flags for the C compiler.  The default is "" (none).
 *
 * testFile         The test file to read and write.  By default the set of
 *                  tests is read from the resource "testCPrintf.xml", but if
 *                  you point this parameter at the actual file, it will be
 *                  maintained with updated "expected" parameters and "failed"
 *                  marks that are useful during development, especially with
 *                  the "run*" parameters described above.
 * writeFile        If "true", the test file will be written with any updates
 *                  made during the run.  The default is "true".  However,
 *                  unless testFile is set to a file you can write, this will
 *                  have no effect, or might overwrite the file in the resources
 *                  directory if it is a "file:" URL.
 *
 * During development, I typically run with runDebug, runFailed, and
 * runIncomplete all "true", runAll false, and "testFile" the "testCPrintf.xml"
 * file stored in SVN ("src/test/resources/.../testCPrintf.xml").  When I am
 * working on a particular batch of tests, I set debug="yes" on them.  When I
 * am trying to work on tests that have failed, I remove the debug attributes.
 * When a test fails, the failed="yes" attribute will be added, and runFailed
 * will cause these tests to be rerun until they work.  And runIncomplete means
 * that I can added tests and they will have their "expected" attributes set
 * automatically and then run, with the results remembered.
 *
 * Each time I run the tests, any changes are written back to the file so the
 * next run will run the right tests (e.g., only those that have failed).
 *
 * If I modify the code sufficiently, I can set regenerateExpected to "true" and
 * those tests I'm working on (the ones with debug="yes", or that have failed)
 * will have their tests regenerated.  After major changes, or before checking
 * in non-trivial changes, I set runAll to "true". (I don't need to change the
 * others to "false").
 *
 * If I change how tests are generated, I set both runAll and regenerateExpected
 * to "true", and all tests will be have their "expected" attributes reset and
 * then be rerun.
 */
public class TestPrintf {
    private static Document expected;
    private static boolean changedDocument;
    private static String cc;
    private static String[] ccFlags;
    private static boolean runDebug;
    private static boolean runFailed;
    private static boolean runIncomplete;
    private static String runConversions;
    private static boolean runAll;
    private static boolean regenerateExpected;
    private static boolean compareApproximate = false;

    private static final Map<Object, Object> unsigned =
            new WeakHashMap<Object, Object>();

    private static final String HEX_DIGITS = "0123456789ABCDEFabcdef";
    private static final Locale TEST_LOCALE = Locale.US;

    @Parameters({
            "runDebug", "runFailed", "runIncomplete", "runConversions",
            "runAll", "regenerateExpected", "CC", "CC_FLAGS"
    })
    @BeforeClass
    public static void setOverallParameters(@Optional("false") boolean runDebug,
            @Optional("false") boolean runFailed,
            @Optional("false") boolean runIncomplete,
            @Optional("") String runConversions,
            @Optional("false") boolean runAll,
            @Optional("false") boolean regenerateExpected,
            @Optional("cc") String cc, @Optional String... ccFlags) {

        TestPrintf.runDebug = runDebug;
        TestPrintf.runFailed = runFailed;
        TestPrintf.runIncomplete = runIncomplete;
        TestPrintf.runConversions = runConversions;
        // unless explicitly told, we don't run all if we are told to run subset
        if (!runAll) {
            runAll = !(runDebug || runFailed || runIncomplete ||
                    runConversions.length() > 0);
        }
        TestPrintf.runAll = runAll;
        TestPrintf.regenerateExpected = regenerateExpected;
        TestPrintf.cc = cc;
        TestPrintf.ccFlags = ccFlags == null ? new String[0] : ccFlags;
    }

    @Parameters("testFile")
    @BeforeClass
    public static void readTestFile(@Optional("") String testFile)
            throws ParserConfigurationException, IOException, SAXException {

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        if (testFile != null && testFile.length() > 0) {
            expected = builder.parse(testFile);
        } else {
            InputStream in = null;
            try {
                String docFile = "testCPrintf.xml";
                in = TestPrintf.class.getResourceAsStream(docFile);
                expected = builder.parse(in);
            } finally {
                IOUtils.closeQuietly(in);
            }
        }
    }

    @Parameters({"writeFile"})
    @AfterClass
    public static void writeTestFile(@Optional("true") boolean writeFile)
            throws TransformerException, IOException {

        if (!writeFile) {
            return;
        }

        if (!changedDocument) {
            return;
        }
        String uri = expected.getBaseURI();
        if (uri == null || !uri.startsWith("file:")) {
            System.err.println("document not from file: " + uri);
            return;
        }

        File outFile = new File(uri.substring(5));
        if (outFile.exists()) {
            File bakFile = new File(outFile.toString() + ".bak");
            if (bakFile.exists() && !bakFile.delete()) {
                throw new IOException(
                        "Could not remove " + bakFile.getCanonicalPath());
            }
            outFile.renameTo(bakFile);
        }

        OutputStream out = null;
        try {
            TransformerFactory factory = TransformerFactory.newInstance();
            Transformer transformer = factory.newTransformer();
            transformer.setOutputProperty(OutputKeys.INDENT, "yes");
            transformer.setOutputProperty(OutputKeys.ENCODING, "ISO-8859-1");
            out = new BufferedOutputStream(new FileOutputStream(outFile));
            transformer.transform(new DOMSource(expected), new StreamResult(
                    out));
        } finally {
            IOUtils.closeQuietly(out);
        }
    }

    @DataProvider(name = "printfTests")
    Iterator<Object[]> printfTests() {
        Node child = expected.getDocumentElement().getFirstChild();
        final Node first = nextTest(child);

        return new Iterator<Object[]>() {
            Node next = first;

            @Override
            public boolean hasNext() {
                return next != null;
            }

            @Override
            public Object[] next() {
                try {
                    return testFor(next);
                } finally {
                    next = nextTest(next.getNextSibling());
                }
            }

            @Override
            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
    }

    private Node nextTest(Node child) {
        Node test = child;
        while ((test = nextNode("test", test)) != null) {
            if (runAll || hasConversion(runConversions, test) || ifPresent(
                    runDebug, test, "debug") || ifPresent(runFailed, test,
                    "failed") || ifAbsent(runIncomplete, test, "expected")) {
                break;
            }
            test = test.getNextSibling();
        }
        return test;
    }

    private static boolean hasConversion(String conversions, Node test) {
        String format = attributeValue(test, "format");
        Matcher m = Stdio.C_FORMAT_PATTERN.matcher(format);
        while (m.find()) {
            if (conversions.indexOf(m.group(Stdio.CONVERSION).charAt(0)) >= 0) {
                return true;
            }
        }
        return false;
    }

    private static boolean ifAbsent(boolean flag, Node test, String attr) {
        return flag && attributeValue(test, attr) == null;
    }

    private static boolean ifPresent(boolean flag, Node test, String attr) {
        return flag && attributeValue(test, attr) != null;
    }

    private static Node nextNode(String name, Node node) {
        while (node != null && !node.getNodeName().equals(name)) {
            String n = node.getNodeName();
            if (n.equals("compare")) {
                adjustComparision(node);
            } else if (n.equals("resetPercentP")) {
                Stdio.resetPercentP();
            }
            node = node.getNextSibling();
        }
        return node;
    }

    private static void adjustComparision(Node node) {
        compareApproximate = attributeValue(node, "approximate").equals("yes");
    }

    private static Object[] testFor(Node testNode) {
        Object[] test = new Object[4];
        test[0] = testNode;
        test[1] = attributeValue(testNode, "expected");
        test[2] = attributeValue(testNode, "format");
        test[3] = toArray(testNode.getChildNodes());
        String isGenerated = attributeValue(testNode, "gen", "yes");
        if (isGenerated.equals("yes")) {
            if (regenerateExpected || test[1] == null) {
                test[1] = generateExepected(test);
                setAttribute(testNode, "expected", (String) test[1]);
                System.out.println("Setting 'expected' to \"" + test[1] + "\"");
            }
        } else {
            if (test[1] == null) {
                throw new IllegalStateException(
                        "No 'expected' attributed for non-generated test: " +
                                testNode);
            }
        }
        return test;
    }

    private static void setAttribute(Node node, String name, String value) {
        NamedNodeMap attrs = node.getAttributes();
        Node attr;
        if ((attr = attrs.getNamedItem(name)) != null) {
            if (!attr.getNodeValue().equals(value)) {
                attr.setNodeValue(value);
                changedDocument = true;
            }
        } else {
            Document doc = node.getOwnerDocument();
            attr = doc.createAttribute(name);
            attr.setNodeValue(value);
            node.getAttributes().setNamedItem(attr);
            changedDocument = true;
        }
    }

    private static void clearAttribute(Node node, String name) {
        NamedNodeMap attrs = node.getAttributes();
        Node attr = attrs.getNamedItem(name);
        if (attr != null) {
            attrs.removeNamedItem(name);
            changedDocument = true;
        }
    }

    private static String generateExepected(Object[] test) {
        //noinspection OverlyBroadCatchBlock
        try {
            File cFile = null;
            cFile = getSourceFileName(cFile);
            writeSource(test, cFile);

            String[] envp = {"LANG=" + TEST_LOCALE, "LC_ALL=" + TEST_LOCALE};

            String[] compileCmd = compileSourceCommand(cFile);
            runCommand(compileCmd, envp, System.out);

            File program = new File(compileCmd[compileCmd.length - 2]);
            String[] runCmd = {program.toString()};
            ByteArrayOutputStream sout = runCommand(runCmd, envp,
                    new ByteArrayOutputStream());

            changedDocument = true;
            cFile.delete();
            program.delete();
            return sout.toString();
        } catch (Exception e) {
            throw new IllegalStateException(
                    "Could not calculate expected value", e);
        }
    }

    private static <T extends OutputStream> T runCommand(String[] cmd,
            String[] envp, T out) throws IOException, InterruptedException {

        Process p = Runtime.getRuntime().exec(cmd, envp);
        p.getOutputStream().close();
        Thread errCopy = copyStream(p.getErrorStream(), System.err);
        Thread outCopy = copyStream(p.getInputStream(), out);

        int status = p.waitFor();
        errCopy.join();
        outCopy.join();
        if (status != 0) {
            throw new IllegalStateException(
                    "Non-zero status (" + status + ") for " + StringUtils.join(
                            cmd, ' '));
        }
        return out;
    }

    private static Thread copyStream(final InputStream from,
            final OutputStream to) {

        Thread copier = new Thread() {
            @Override
            public void run() {
                try {
                    byte[] buf = new byte[8 * 1024];
                    int len;
                    while ((len = from.read(buf)) > 0) {
                        to.write(buf, 0, len);
                    }
                } catch (IOException e) {
                    throw new IllegalStateException("Problem copying", e);
                }
            }
        };
        copier.start();
        return copier;
    }

    @DataProvider(name = "casesForN")
    private Object[][] casesForN() {
        return new Object[][]{
                {"hh", byte.class}, {"h", short.class}, {"", int.class},
                {"l", int.class}, {"ll", long.class}, {"j", int.class},
                {"t", int.class}, {"z", int.class}, {"q", long.class},
        };
    }

    /**
     * %n in C means "Store the number of characters output thus far by this
     * printf into the integer my parameter is pointing at."  Java does not have
     * pointers, but it does have arrays.
     * <p/>
     * This is not automated because it would require a mechanism to allocate an
     * array of an appropriate type and check its value.  This is more complex
     * than simply writing the code to test it.  This is especially so because
     * it needs to be tested for all the integer types that can be designated by
     * the length modifier.
     *
     * @param modifier       The length modifier to be tested.
     * @param componentClass The type of array to allocate.
     */
    @Test(dataProvider = "casesForN")
    public void lowercaseN(String modifier, Class<Byte> componentClass) {
        tryPrintfLowercaseN("", "%n", new int[]{0}, componentClass, modifier,
                new Object[]{null});
        tryPrintfLowercaseN("hi  there ", "%nhi %n there %n",
                new int[]{0, 3, 10}, componentClass, modifier, null, null,
                null);
        tryPrintfLowercaseN("|hi  there ", "%n|%s %n %s %n",
                new int[]{0, 3, 10}, componentClass, modifier, null, "hi", null,
                "there", null);
    }

    private void tryPrintfLowercaseN(String expectedStr, String format,
            int[] expectedVals, Class componentClass, String modifier,
            Object... vals) {

        format = format.replaceAll("%n", "%" + modifier + "n");
        int numAllocated = allocateArraysForResults(componentClass, vals);
        if (numAllocated != expectedVals.length) {
            throw new IllegalArgumentException(
                    "Mismatch between expected and paramters");
        }
        tryPrintf(null, expectedStr, format, vals);
        compareActualToExpected(expectedVals, vals);
    }

    private static void compareActualToExpected(int[] expectedVals,
            Object... vals) {
        int whichValue = 0;
        for (Object val : vals) {
            if (val.getClass().isArray()) {
                int pos = Array.getInt(val, 0);
                assertEquals(pos, expectedVals[whichValue++],
                        "value " + whichValue);
            }
        }
    }

    private int allocateArraysForResults(Class componentClass, Object... vals) {
        int numAllocated = 0;
        for (int i = 0; i < vals.length; i++) {
            if (vals[i] == null) {
                vals[i] = Array.newInstance(componentClass, 1);
                numAllocated++;
            }
        }
        return numAllocated;
    }

    private static String[] compileSourceCommand(File cFile)
            throws IOException {
        String cFilePath = cFile.getCanonicalPath();
        List<String> cmdArgs = new ArrayList<String>();
        cmdArgs.add(cc);
        cmdArgs.addAll(Arrays.asList(ccFlags));
        cmdArgs.add("-o");
        cmdArgs.add(cFilePath.substring(0, cFilePath.length() - 2));
        cmdArgs.add(cFilePath);
        return cmdArgs.toArray(new String[cmdArgs.size()]);
    }

    private static void writeSource(Object[] test, File cFile)
            throws IOException {

        StringWriter sout = new StringWriter();
        PrintWriter out = new PrintWriter(sout);
        out.println("#include <stdio.h>");
        out.println("#include <stdint.h>");
        out.println("#include <math.h>");
        out.println("int main(argc, argv)");
        out.println("int argc;");
        out.println("char **argv;");
        out.println("{");
        Object[] args = (Object[]) test[3];
        out.println("    " + showCPrintf(test[2].toString(), args) + ";");
        out.println("    return 0;");
        out.println("}");
        out.close();
        String programText = sout.toString();

        System.out.println("C source:");
        System.out.println(programText);

        FileWriter fout = null;
        try {
            fout = new FileWriter(cFile);
            fout.write(programText);
        } finally {
            IOUtils.closeQuietly(fout);
        }
    }

    private static File getSourceFileName(File cFile) throws IOException {
        cFile = File.createTempFile("test", ".c");
        return cFile;
    }

    private static Object[] toArray(NodeList nodes) {
        Collection<Object> values = new ArrayList<Object>();
        for (Node child = nextNode("arg", nodes.item(0));
             child != null;
             child = nextNode("arg", child.getNextSibling())) {

            String type = attributeValue(child, "type");
            String text = child.getTextContent();
            char firstCh = type.charAt(0);
            boolean isUnsigned = firstCh == 'u';
            if (isUnsigned) {
                firstCh = type.charAt(1);
            }
            Object obj;
            switch (firstCh) {
            case 'S':
                values.add(obj = text);
                break;
            case 'b':
                // This way of converting allows larger-than-byte values to be truncated instead of rejected
                values.add(obj = (byte) Long.decode(text).longValue());
                break;
            case 's':
                // This way of converting allows larger-than-short values to be truncated instead of rejected
                values.add(obj = (short) Long.decode(text).longValue());
                break;
            case 'i':
                // This way of converting allows larger-than-int values to be truncated instead of rejected
                values.add(obj = (int) Long.decode(text).longValue());
                break;
            case 'l':
                try {
                    values.add(obj = Long.decode(text));
                } catch (NumberFormatException e) {
                    int base = 10;
                    if (text.startsWith("0x")) {
                        base = 16;
                        text = text.substring(2);
                    } else if (text.charAt(0) == '0') {
                        base = 8;
                    }
                    // handle value not in long range (i.e. large unsigned long)
                    Number big = new BigInteger(text, base);
                    values.add(obj = big.longValue());
                }
                break;
            case 'f':
                // This way of converting allows larger-than-float values to be truncated instead of rejected
                values.add(obj = (float) Double.valueOf(text).doubleValue());
                break;
            case 'd':
                values.add(obj = Double.valueOf(text));
                break;
            case 'c':
                if (text.length() == 1) {
                    obj = text.charAt(0);
                } else {
                    obj = Integer.decode(text);
                }
                values.add(obj);
                break;
            default:
                throw new IllegalArgumentException(
                        "Unexpected type: " + type + ": " + child.getBaseURI() +
                                ":" + child.getParentNode().toString());
            }
            if (isUnsigned) {
                unsigned.put(obj, null);
            }
        }
        return values.toArray();
    }

    private static String attributeValue(Node nextTest, String s) {
        return attributeValue(nextTest, s, null);
    }

    private static String attributeValue(Node nextTest, String s, String def) {
        Node item = nextTest.getAttributes().getNamedItem(s);
        if (item == null) {
            return def;
        } else {
            String str = item.getTextContent();
            return str == null ? "" : str;
        }
    }

    @Test(dataProvider = "printfTests")
    public void tryPrintf(Node test, String expected, String cFmt,
            Object... args) {

        boolean worked = false;
        try {
            StringBuilder out = new StringBuilder();
            Formatter formatter = new Formatter(out, TEST_LOCALE);
            Stdio p = new Stdio(formatter);
            System.out.println("C:  " + showCPrintf(cFmt, args));
            p.printf(cFmt, args);
            if (compareApproximate) {
                assertApproximateEquals(out.toString(), expected, showCPrintf(
                        cFmt, args));
            } else {
                assertEquals(out.toString(), expected, showCPrintf(cFmt, args));
            }
            worked = true;
        } finally {
            if (test != null) {
                if (!worked) {
                    setAttribute(test, "failed", "yes");
                } else {
                    clearAttribute(test, "failed");
                }
            }
        }
    }

    private static void assertApproximateEquals(String actual, String expected,
            String message) {

        if (actual.equals(expected)) {
            return;
        }

        int end = Math.min(actual.length(), expected.length());

        // Find the first matching chars, counting the significant digits
        int first;
        int digits = 0;
        for (first = 0; first < end; first++) {
            char ach = actual.charAt(first);
            char ech = expected.charAt(first);
            if (ach != ech) {
                break;
            }
            if (HEX_DIGITS.indexOf(ach) >= 0) {
                digits++;
            }
        }
        if (first >= 1 && (actual.startsWith("0x") || actual.startsWith(
                "0X"))) {
            digits--;   // this counted the "0" in "0x"
        }

        boolean foundExp = false;
        int last;
        for (last = 1; last <= end; last++) {
            char ach = actual.charAt(actual.length() - last);
            char ech = expected.charAt(expected.length() - last);
            if (ach != ech) {
                break;
            }
            if ("EePp".indexOf(ach) >= 0) {
                foundExp = true;
            }
        }

        if (digits >= 4 && foundExp && allFloatParts(actual, first, last) &&
                allFloatParts(expected, first, last)) {
            System.out.printf(
                    "APPROXIMATION: \"%s\" ~= \"%s\", with %d digits of precision as equal%n",
                    actual, expected, digits);
            return;
        }

        // Using this because it generates a good output
        assertEquals(actual, expected, message);
    }

    private static boolean allFloatParts(CharSequence str, int first,
            int last) {
        for (int i = first; i <= str.length() - last; i++) {
            char c = str.charAt(i);
            if (c != '.' && HEX_DIGITS.indexOf(c) < 0) {
                return false;
            }
        }
        return true;
    }

    static String showCPrintf(CharSequence fmt, Object... args) {
        StringBuilder sb = new StringBuilder();
        sb.append("printf(").append('"').append(escapeString(fmt)).append('"');
        for (Object arg : args) {
            sb.append(", ");
            if (arg instanceof CharSequence) {
                sb.append('"').append(escapeString(arg)).append('"');
            } else if (arg instanceof Character) {
                sb.append("'").append(escapeString(arg)).append("'");
            } else if (arg.getClass().isArray() ||
                    arg instanceof PositionRecorder) {
                // Only happens for C's %n, before or after Stdio rewrite
                // It never happens when using this to generate expected answers
                sb.append("(int *) null");
            } else if (arg instanceof Number) {
                sb.append(typeFor((Number) arg));
                if (arg instanceof Float || arg instanceof Double) {
                    // This is in case it is "NaN" or "Infinity"
                    String toPrint = arg.toString().toUpperCase();
                    sb.append(toPrint);
                    if (toPrint.indexOf('N') < 0) {
                        sb.append('L');
                    }
                } else if (arg instanceof Long) {
                    sb.append(arg).append("LL");    // "LL" for long long
                } else {
                    sb.append(arg).append('L');
                }
            } else {
                throw new IllegalArgumentException(
                        "Unknown type for C: " + arg.getClass());
            }
        }
        sb.append(")");
        return sb.toString();
    }

    private static CharSequence typeFor(Number arg) {
        StringBuilder sb = new StringBuilder();
        sb.append("(");
        if (unsigned.containsKey(arg)) {
            sb.append("u");
        }
        if (arg instanceof Long) {
            sb.append("int64_t");
        } else if (arg instanceof Float) {
            sb.append("double");
        } else if (arg instanceof Double) {
            sb.append("double");
        } else if (arg instanceof Byte || arg instanceof Short ||
                arg instanceof Integer) {
            sb.append("int32_t");
        }
        sb.append(")");
        return sb;
    }
}